========,1,preface.
Structured programming is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by making extensive use of subroutines, block structures, for and while loops—in contrast to using simple tests and jumps such as the "go to" statement which could lead to "spaghetti code" causing difficulty to both follow and maintain.
It emerged in the late 1950s with the appearance of the ALGOL 58 and ALGOL 60 programming languages, with the latter including support for block structures.
Contributing factors to its popularity and widespread acceptance, at first in academia and later among practitioners, include the discovery of what is now known as the structured program theorem in 1966, and the publication of the influential "Go To Statement Considered Harmful" open letter in 1968 by Dutch computer scientist Edsger W. Dijkstra, who coined the term "structured programming".
Structured programming is most frequently used with deviations that allow for clearer programs in some particular cases, such as when exception handling has to be performed.
========,2,Structured programming languages.
It is possible to do structured programming in any programming language, though it is preferable to use something like a procedural programming language.
Some of the languages initially used for structured programming include: ALGOL, Pascal, PL/I and Ada – but most new procedural programming languages since that time have included features to encourage structured programming, and sometimes deliberately left out features – notably GOTO – in an effort to make unstructured programming more difficult.
"Structured programming" (sometimes known as modular programming) enforces a logical structure on the program being written to make it more efficient and easier to understand and modify.
========,2,History.
========,3,Theoretical foundation.
The structured program theorem provides the theoretical basis of structured programming.
It states that three ways of combining programs—sequencing, selection, and iteration—are sufficient to express any computable function.
This observation did not originate with the structured programming movement; these structures are sufficient to describe the instruction cycle of a central processing unit, as well as the operation of a Turing machine.
Therefore, a processor is always executing a "structured program" in this sense, even if the instructions it reads from memory are not part of a structured program.
However, authors usually credit the result to a 1966 paper by Böhm and Jacopini, possibly because Dijkstra cited this paper himself.
The structured program theorem does not address how to write and analyze a usefully structured program.
These issues were addressed during the late 1960s and early 1970s, with major contributions by Dijkstra, Robert W. Floyd, Tony Hoare, Ole-Johan Dahl, and David Gries.
========,3,Debate.
P. J. Plauger, an early adopter of structured programming, described his reaction to the structured program theorem:
Donald Knuth accepted the principle that programs must be written with provability in mind, but he disagreed (and still disagrees) with abolishing the GOTO statement.
In his 1974 paper, "Structured Programming with Goto Statements", he gave examples where he believed that a direct jump leads to clearer and more efficient code without sacrificing provability.
Knuth proposed a looser structural constraint: It should be possible to draw a program's flow chart with all forward branches on the left, all backward branches on the right, and no branches crossing each other.
Many of those knowledgeable in compilers and graph theory have advocated allowing only reducible flow graphs.
Structured programming theorists gained a major ally in the 1970s after IBM researcher Harlan Mills applied his interpretation of structured programming theory to the development of an indexing system for the "New York Times" research file.
The project was a great engineering success, and managers at other companies cited it in support of adopting structured programming, although Dijkstra criticized the ways that Mills's interpretation differed from the published work.
As late as 1987 it was still possible to raise the question of structured programming in a computer science journal.
Frank Rubin did so in that year with an open letter titled ""GOTO considered harmful" considered harmful".
Numerous objections followed, including a response from Dijkstra that sharply criticized both Rubin and the concessions other writers made when responding to him.
========,3,Outcome.
By the end of the 20th century nearly all computer scientists were convinced that it is useful to learn and apply the concepts of structured programming.
High-level programming languages that originally lacked programming structures, such as FORTRAN, COBOL, and BASIC, now have them.
========,2,Common deviations.
While goto has now largely been replaced by the structured constructs of selection (if/then/else) and repetition (while and for), few languages are purely structured.
The most common deviation, found in many languages, is the use of a return statement for early exit from a subroutine.
This results in multiple exit points, instead of the single exit point required by structured programming.
There are other constructions to handle cases that are awkward in purely structured programming.
========,3,Multiple entry.
More rarely, subprograms allow multiple "entry."
This is most commonly only "re"-entry into a coroutine (or generator/semicoroutine), where a subprogram yields control (and possibly a value), but can then be resumed where it left off.
There are a number of common uses of such programming, notably for streams (particularly input/output), state machines, and concurrency.
From a code execution point of view, yielding from a coroutine is closer to structured programming than returning from a subroutine, as the subprogram has not actually terminated, and will continue when called again – it is not an early exit.
However, coroutines mean that multiple subprograms have execution state – rather than a single call stack of subroutines – and thus introduce a different form of complexity.
It is very rare for subprograms to allow entry to an arbitrary position in the subprogram, as in this case the program state (such as variable values) is uninitialized or ambiguous, and this is very similar to a goto.
========,3,State machines.
Some programs, particularly parsers and communications protocols, have a number of states that follow each other in a way that is not easily reduced to the basic structures, and some programmers implement the state-changes with a jump to the new state.
This type of state-switching is often used in the Linux kernel.
However, it is possible to structure these systems by making each state-change a separate subprogram and using a variable to indicate the active state (see trampoline).
Alternatively, these can be implemented via coroutines, which dispense with the trampoline.
